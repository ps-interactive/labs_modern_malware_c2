# HTTPS (TLS)


## Server TLS

Why doesn't everyone do this?



Great question! 

Setup wireshark for ja3 hashes by first making sure it is stopped.

```
cd /home/pslearner/Desktop/LAB_FILES/c2_behavior
sudo cp ja3.lua /usr/lib/x86_64-linux-gnu/wireshark/plugins/
sudo cp md5.lua /usr/lib/x86_64-linux-gnu/wireshark/plugins/
```


Examine the differences from the previous code in VSCode, opening the **ichttpsc2>server>server.go** file.


First you notice, the server hast to actualy have as certificate. Lines ~30 to 39.  These are all items that you cna change. The host name will need to reflect the name & IP of your server.

Get the name and IP of your Linux desktop and replace the local host values.

```
hostname
ip addr
```

> This generates a self signed cert, that is unique to the runtime of the given client. You can imagine these values could be randomized.

The section you notice different is lines 47 to 57 being used for public key generation as well. Nothing to be done here.

Travel down to line ~192 There is some robust error checking here but the big thing to look at is the Template line ~242.  In the Organization String, you can set it to anything you want. Feel free to do so.
> The rest of this code aprses the variables you set above and out pops a cert and key.pem. 

Now, around line 305, instead of seeing the r.RUN for the normal router, you run the RunTLS function instead and give it both pem files...That's it!. Go ahead and compile the server with the updated host information.


```
sudo go build server.go
```

Then open a terminal, or used the terminal used used for the other server and re-run the tls server.

```
cd /home/pslearner/LAB_FILES/c2_behavior/ichttpsc2/server
sudo ./server
```

Open a browser on your linux desktop and browse to the newly secured website.  You can use the /ironcat endpoint so you don't get redirected.

Because a CA wasn't used, you do have to accept it as it is. But it is just as effective when used to encrypt traffic.

> Inspect the certificate in the browser.

## Client TLS

Now to fix up the client.

Open the client>client.go file in the ichttpsc2 folder in VSCode.

The only change here is the inclusion of the configuration for handling TLS with the standard client being used. Around line ~24 there is the configuration for tls and it is added to the transport, which is then used by the client. That client is repeatedly used for subseuqent requests in the different functions. That's it!

Modify the Ip string to be your linux server's ip on line 17.  Also note that the checkin and c2 endpoint now include (s). Your ip should be 172.31.24.10
To get your IP.

```
ip addr
``` 

Compile the client and move it over to the windows device.

```
sudo GOOS=windows GOARCH=x64 go build client.go
python -m http.server
```

Download and run the new client on your windows device. Then check back on your linux serverfor the connection.

For the caputre filter use `tcp port https`

For the live filter use `ssl`.

Follow one of the tcp streams.

> Now you can't read anything can you!!!!

Expand the Server Hello. You will se the organizational name as part of the certificate.


Expand the Client Hello, and notice the JA3 hash. This can be used quiet successfully as an IOC. Write down the first 4 letters of the hash.

## TLS and Cipher Suite

Go ahead and stop the client on the windows victim and delete the file.

```
ctrl+c
del client.exe
```

Head back to Linux Desktop environment and VSCode.

In the client code, modify the conf line ~26 and remove the comments on the lines for min and max tls version.

Save the file. Recompile, host and move over to windows, and run the new client.

Check in linux in wireshark for the new connections. Look at the Client Hello, notice the JA3 has changes. Simply by modifying the min and max versions and changes the allowed cipher suites presented in the Client and Server negotiation.

Mind blown. Have fun.



